#' MixTCRviz: Plot TCR motifs
#'
#' MixTCRviz is an R package to display TCR binding motifs for a set of TCRs provided by the user.
#' Typically, the input TCRs correspond to TCRs binding to a specific epitope, or isolated in a specific experiment.
#' MixTCRviz compares V usage, J usage, CDR3 length distribution and CDR3 sequence motifs to those expected from baseline TCR repertoire.
#'
#' @param input1 Either a .csv or .txt or .tsv file with the input TCRs, or a data.frame with the input TCRs, or list in the MixTCRviz format.
#'    * Columns should ideally include 'TRAV','TRAJ','cdr3_TRA','TRBV','TRBJ','cdr3_TRB' (single chain are also allowed)
#'    * If TCRs from multiple experiments/epitopes/classses/... are provided in the same file, the 'model' column should indicate the models
#'    ("Model_default" is used by default if no 'model' column is provided and `model.default`=NULL, see below).
#'    * If TCRs from multiple species are provided in the same file, the 'species' column should indicate the species of the TCRs
#'    ("HomoSapiens" or "MusMusculus", with "HomoSapiens" being the default if no 'species' column and `species.default`=NULL).
#'    * The 'TRAV', 'TRAJ', 'TRBV', 'TRBJ' should follow the IMGT nomenclature, with or without allele (see below for V/J name correction options).
#'    * The 'cdr3_TRA' and 'cdr3_TRB' columns should provide CDR3A/CDR3B sequences, following the standard definition (e.g., CAVNSDGQKLLF).
#'   Cases with non-amino acid characters, or length < 7 or > 22 will be not be considered. See below for CDR3 sequence QC.
#'    * Some other column names (e.g., Va instead of TRAV) and/or input format are supported (but these shoudl be used with care).
#'    * Using full TCR sequences ("TCRa" and "TCRb") is also supported and the V/J/CDR3 can be inferred with infer.VJ=T and infer.CDR3=T
#'
#' @param output.path Name of the output directory (default=NULL). If not already existing, it
#'   will be created. If existing, files with the same name will be overwritten.
#'   If left empty, nothing will be written, and only R objects will be returned.
#'
#' @param input2 .csv, .tsv of tab delimited .txt filename, or data.frame containing a second set of
#'   TCRs to be used in comparisons. Same format as input1, except that all TCRs are assumed to come from a single model so any data in the 'model' column is omitted.
#'   If input2 is provided, the comparisons is performed with this second input, and not the baseline
#'   repertoire. In this case, all models provided in input1 will be compared with the repertoire in input2, and multiple species should not be mixed in input1.
#'   Other than filename or data.frame, a third alternative consists of a list or .rds file with precomputed statistics,
#'   such as those generated by MixTCRviz::build_stat() function. default=NULL.
#'
#' @param baseline R object (list) or name of a .rds/.rda/.rdata file containing all data about the
#'   baseline repertoire to be used, in the same format as the default repertoires.
#'   If .rda file, the object containing the data about the repertoires must be called 'baseline'.
#'   Alternatively one of the strings: "Default" or "SEQTR" for data in input1 generated by publicly available TCR-seq approaches (Default) or SEQTR (SEQTR) protocols.
#'   If empty, the default baseline repertoires are used. default=NULL.
#'
#' @param use.allele Decide whether alleles should be used
#'    * FALSE (default): All V/J alleles are merged at the gene level (recommended).
#'    * TRUE: Alleles are kept. If some entries do not include alleles, the most frequent one is added.
#'   Currently, `use.allele` is fixed to FALSE for mouse TCRs.
#'
#' @param correct.gene.names Decide how to correct V/J names
#'    * FALSE: Do not attempt to correct V/J gene names. Put to NA genes not in IMGT.
#'    * TRUE (default): Attempt to correct V/J gene names not in IMGT based on our internal dictionary.
#'     V/J names which could not be corrected are put to NA.
#'
#' @param use.mouse.strain Decide whether or not to merge TRAV genes corresponding to different strains (e.g., TRAV10, TRAV10D, TRAVN10)
#'    * FALSE (default): Merge the different TRAV genes corresponding to different mouse strains (e.g., TRAV10D, TRAVN10 and TRAV10 become all TRAV10).
#'      This is recommended the recommended option.
#'    * TRUE: The different TRAV segments (e.g., TRAV10D, TRAVN10 and TRAV10) are treated separately.
#'      In general, this is NOT recommended since the baseline is challenging to establish. Should be used only if you have a baseline coming from same mice used in input1.
#'
#' @param check.cdr3.mode Decide how to check CDR3 sequences for compatibility with V/J genes
#'    * 0: Keep all CDR3 without any correction.
#'    * 1 (default): Remove V and CDR3 when the first CDR3 amino acid is incompatible with the V segment;
#'        Remove J and CDR3 when the last 2 amino acids are not compatible with the J segments.
#'        Allow compatibility check with any allele.
#'
#' @param renormVJ Decide whether or not to build baseline length distribution and CDR3 motif for P(VJ) in input1.
#'    * NULL: If left empty, 1 is used if comparison is performed with a baseline (`input2`==NULL)
#'      and 0 is used if comparison is performed with input2 (i.e., `input2` != NULL)
#'    * 0: Compare CDR3 length distribution and motif with those from the baseline repertoire or input2
#'    * 1 (default): Compare CDR3 length distribution and motif with those from the baseline repertoire with the V-J
#'   usage observed in the input TCRs. In the plots the mark " | P(VJ)" is used to
#'   indicate that CDR3 length distributions and motifs correspond to those
#'   expected with the V-J usage in the TCRs used for training.
#'
#' @param N.min Minimum number of TCRs (i.e., V-J-CDR3) for at least
#'   one chain. This number is computed after cleaning the data (default=1) .
#'
#' @param output.stat Print the stats in a file.
#'    * FALSE (default): Do not print the stats
#'    * TRUE: create a output.path/stat/ folder with .rds files summarizing the raw statistics for each model. Requires `output.path` to be initialized.
#'
#' @param output.processed.data Print the processed data (after the different cleaning steps).
#'    * FALSE (default): Do not print the processed/clean data to a file
#'    * TRUE: create a output.path/processed_data/ folder with the data for each model after the different processing steps
#'   (e.g., removing alleles, correcting V/J names, removing inconsistent CDR3, etc. depending on the cleaning option selected). Requires `output.path` to be initialized.
#'
#' @param set.cdr3a.length,set.cdr3b.length Length for the CDR3 motif to be shown in the main plot (default=NA).
#'   If left empty, the value corresponding to the most frequent CDR3 length in input1 (and also present in input2 if input2 is provided) is chosen.
#'
#' @param start.lg,end.lg Number of amino acids at the beginning and end of CDR3 used to check compatibility with VJ annotations (default = 1 and 2).
#'
#' @param species.default Option to provide the species for all the TCR in input1 (default="HomoSapiens").
#'   This is useful if your input does not contain a 'species' column.
#'   In case the input contains the 'species' column, `species.default` is not considered.
#'   Should be either "HomoSapiens" or "MusMusculus"
#'
#' @param model.default  Option to provide the model for all the TCR in input1 (default="Model_default"), which is also used as the name of the output files.
#'   This is useful if your input does not contain a 'model' column.
#'   In case the input contains the 'model' column, `model.default` is not considered.
#'
#' @param filename.output Provide a name for the output file (default=NULL).
#'  This option should not be used if input1 contains data from multiple models.
#'  If NULL, the value(s) in the 'model' column of input1 are used (i.e., input1$model).
#'    If no 'model' column is provided, the value in `model.default` is used.
#'
#' @param verbose Decide how much information is given in the R Console.
#'    * 0: Do not write any QC in the output
#'    * 1 (default): Write max 10 examples of putative issues with the data (V/J names, CDR3 sequences, etc.) in the Console
#'    * 2: Write all the putative issues with the data (V/J names, CDR3 sequences, etc.) in the Console
#'    * 3: Write all putative issues + cases that were corrected (can be long depending on your data).
#'
#' @param plot Decide whether or not to plot the motifs.
#'    * FALSE: Do not build the motifs. This overrides `plot.all.length`=T and `interactive.plots`=T
#'    * TRUE (default): Build the motifs
#'
#' @param plot.cdr12.motif Decide whether or not to show the motifs for CDR1 and CDR2.
#'    * FALSE (default): Only show motifs for CDR3.
#'    * TRUE: Include sequence motifs for CDR1 and CDR2. With this choice, `plot.oneline` is set to 0. This information is redundant with V usage.
#'
#' @param plot.oneline Decide how to plot the motifs.
#'    * 0 (default): Show the data on two lines (better for clarity).
#'    * 1: Show all plots in a single line (can be useful to compare different models).
#'    * 2: Show only V/J usage and length (i.e., do not show CDR3 motifs).
#'
#' @param plot.all.length Decide whether to plot the motifs for each CDR3 length.
#'    * FALSE (default): Show only the CDR3 motifs for the most frequent CDR3 length.
#'    * TRUE: Write in `output.path`/CDR3_length distinct plots for the V usage, J usage and CDR3 motifs
#'     for all CDR3 lengths. Only applicable if `plot`=T.
#'
#' @param plot.cdr3.norm Decide how to build the motifs for the baseline.
#'    * 0 (default): Show the CDR3 motifs of the input and of the baseline repertoire or input2, possibly | P(VJ).
#'    * 1: Show the CDR3 motifs of the input TCRs after subtracting the baseline repertoire (not recommended due to poor readability).
#'    * 2: Show the CDR3 motifs of the input TCRs after normalising by the baseline repertoire (motif of normalised fold-change, not recommended due to poor readability)
#'
#' @param plot.sd Decide whether to include standard deviation in P(V), P(J) and P(L) plots.
#'    * TRUE (default): Show standard deviation for P(V), P(J) and P(L), if such data are provided for baseline and/or input1.
#'    * FALSE: Do not show standard deviation
#'
#' @param plot.VJ.switch Change the color and/or format of the motifs.
#'    * 1 (default): Show the VJ usage as a scatter plot with inner colors, outer colors and shapes of the points based
#'       on the V/J gene names (see lookup table in MixTCRviz/figures/, scheme1).
#'    * 1.2: Show the VJ usage as a scatter plot with colors of the points based
#'       on the V/J gene names (see lookup table in MixTCRviz/figures/, scheme2).
#'    * 1.3: Show the VJ usage as a scatter plot with black points and V/J gene label in colors (see lookup table in MixTCRviz/figures/, scheme2).
#'    * 2 and 2.1: Show the VJ usage as a bar plot (see lookup table in
#'        MixTCRviz/figures/, scheme2). With 2, only the bars of the most
#'        significantly enriched genes are showed, while with 2.1 we add a bar
#'        of the "Other" genes, summing the frequencies of all remaining genes.
#'
#' @param plot.modelsCombined Decide whether to combine the different models.
#'    * FALSE (default) or empty string: Show the data for each model separately.
#'    * TRUE or a string: Show the data for all models combined in a single
#'        figure (based on the format `plot.VJ.switch`=2). When given as a
#'        logical, the default name "modCombined" is used. Otherwise, the string
#'        is used for the resulting figure filename.
#'
#' @param label.neg Show the label of V/J genes negatively enriched in input1 (default=FALSE).
#' If TRUE, show also the labels of the genes most depleted in input1.
#'
#' @param label.diag  Decide to keep some label in the upper right corner, based on label.diag value (default=0.3).
#'        This can be especially useful when comparing two epitope-specific TCR repertoires.
#'
#' @param label.min.fr.input1,label.min.fr.input2 Region (i.e., Y - X rectangle) of the left corner of V/J plots with no gene label (default=0.05).
#'
#' @param keep.incomplete.chain Decide whether to keep incomplete alpha or beta chains.
#'  * TRUE : Incomplete chains are kept.
#'  * FALSE (default): Incomplete chains are discarded. Even if input1 only consists of complete chains, incomplete chains can occur when one V/J gene cannot be corrected,
#'      or when there is some incompatibilities between V/J names and CDR3 sequences
#'
#' @param chain Decide which chain to show in the motifs.
#'    * "AB" (default): both chains are plotted in output.
#'    * "A": Only the alpha chain is plotted in output.
#'    * "B": Only the beta chain is plotted in output.
#'
#' @param input1.name,input2.name Provide a generic name for the TCRs in input1 or input2 (default="Input" and "Baseline"/"Input2"). Avoid names with more
#'   than 20 characters.
#'
#' @param output.format Choose the format for the output, can be "pdf" (default), "png" or "jpg".
#'
#' @param seq.protocol Indicate the sequencing protocol ("Default" or "SEQTR").
#' When using SEQTR, TRBV12-3 and TRBV12-4 are merged into TRBV12-3/12-4, since they cannot be distinguished with this protocol.
#'
#' @param interactive.plots Decide whether to plot interactive html plots.
#'    * FALSE (default): Do not create an html file with interactive plots.
#'    * TRUE: Create an html file with interactive plots. Only applicable if `output.path` is set and `plot`=T. Takes slightly longer
#'
#' @param print.size If TRUE (default), print the number of TCRs in input1 in the plots.
#'
#' @param plot.title If TRUE (default), print the model name as title to the plots.
#'
#' @param set.title Set the title of the plots (default=NULL).
#'  If NULL, input1$model are used as titles. If no 'model' column is provided in input1, `model.default` is used.
#'
#' @param build.clones Decide whether to reconstruct the clones if the data are provided in format with clone.id (default=FALSE).
#'  If TRUE and if the data are provided in format with clone.id/complex.id/..., reconstruct the actual clones in output
#'
#' @param ZscoreVJ.thresh Filtering threshold based on Z-score for not showing the labels in P(V) and P(J) plots (default=0, i.e. no filtering)
#' The Z-score filtering comes on top of the filtering with min.label.fr.input1 and min.label.fr.input2
#'
#' @param FoldChangeVJ.thresh Filtering threshold based on fold change for not showing the labels in P(V) and P(J) plots (default=1.25, must be larger than 1).
#' This parameter is overruled by label.diag, so V/J genes with frequencies in input1 or in input2/baseline larger than label.diag will still be displayed.
#' This can be prevented by using label.diag=1.
#' The Fold Change filtering comes on top of the filtering with min.label.fr.input1 and min.label.fr.input2
#' If too many labels remain in the plots, other FoldChangeVJ.thresh values may be used.
#'
#' @param logo.type Decide which type of logo to use. Should be either 'bits' (default), or 'probability'.
#'
#' @param infer.VJ If TRUE, the V and J genes are inferred from full TCRa and TCRb sequences (default if FALSE).
#' This option requires 'TCRa' and 'TCRb' columns to be included and will overwrite any TRAV,TRAJ,TRBV,TRBJ information
#'
#' @param infer.CDR3 If TRUE, the CDR3 are inferred from full TCRa and TCRb sequences (default if FALSE).
#' This option requires 'TCRa' and 'TCRb' columns to be included and will overwrite any cdr3_TRA,cdr3_TRB information
#'
#' @returns R list containing the plots (if `plot`=TRUE), the processed data (if input1 is a file or data.frame) and an R list with the stats for each model in input1.
#'
#' @usage MixTCRviz(input1="test/test.csv", output.path = YOUR_PATH, ...)
#'
#' @export
MixTCRviz <- function(input1, output.path=NULL, input2=NULL, baseline=NULL, chain="AB", interactive.plots = F,
                      use.allele=F, correct.gene.names=T, use.mouse.strain=F, check.cdr3.mode=1, start.lg=1, end.lg=2,
                      renormVJ=NULL, N.min=1, output.stat=F, output.processed.data=F, filename.output=NULL,
                      set.cdr3a.length=NA, set.cdr3b.length=NA, plot.title=T, set.title=NULL,logo.type="bits",
                      species.default="HomoSapiens", model.default="Model_default", verbose=1, build.clones=F,
                      plot=T, plot.cdr12.motif=F, plot.oneline=0, plot.all.length=F, plot.cdr3.norm=0,
                      plot.VJ.switch=1, plot.modelsCombined=FALSE, label.neg=F, label.diag=0.3, plot.sd=T,
                      label.min.fr.input1=0.05, label.min.fr.input2=0.05, keep.incomplete.chain=F, seq.protocol="Default",
                      input1.name="Input", input2.name=NULL, output.format="pdf", infer.VJ=F, infer.CDR3=F,
                      print.size=T, ZscoreVJ.thresh=0, FoldChangeVJ.thresh=1.25){


  #######
  # Check input parameters
  #######

  if(!seq.protocol %in% c("Default", "SEQTR")){
    print("Invalid value for seq.protocol. Default value of \"Default\" will be used")
    seq.protocol <- "Default"
  }
  if(seq.protocol=="SEQTR"){
    if(is.null(baseline)){
      baseline="SEQTR"
    }
  }


  if(!is.numeric(ZscoreVJ.thresh) | length(ZscoreVJ.thresh)>1){
      print("Invalid value for ZscoreVJ.thresh. Default value of 0 will be applied")
      ZscoreVJ.thresh <- 0
  } else {
    if(ZscoreVJ.thresh < 0){
      print("ZscoreVJ.thresh needs to be larger or equal to 0. Default value of 0 will be applied")
      ZscoreVJ.thresh <- 0
    }
  }
  if(!is.numeric(FoldChangeVJ.thresh) | length(FoldChangeVJ.thresh)>1){
    print("Invalid value for FoldChangeVJ.thresh. Default value of 1.25 will be used")
    FoldChangeVJ.thresh <- 1.25
  } else {
    if(FoldChangeVJ.thresh < 1){
      print("FoldChangeVJ.thresh needs to be larger or equal to 1. Default value of 1.25 will be applied")
      FoldChangeVJ.thresh <- 1.25
    }
  }

  if(!is.null(baseline)){
    if(is.character(baseline) & length(baseline)==1){
      if(baseline=="SEQTR"){
        seq.protocol="SEQTR"
      }
    }
  }

  if(!is.logical(output.stat)){
    print("Invalid value for output.stat. Default value of FALSE will be used")
    output.stat <- F
  }

  if(!is.logical(output.processed.data)){
    print("Invalid value for output.processed.data. Default value of FALSE will be used")
    output.processed.data <- F
  }

  if(!is.logical(interactive.plots)){
    print("Invalid value for interactive.plots Default value of FALSE will be used")
    interactive.plots <- F
  }

  if(!is.logical(plot.all.length)){
    print("Invalid value for plot.all.length. Default value of FALSE will be used")
    plot.all.length <- F
  }

  if(!is.logical(plot)){
    print("Invalid value for plot. Default value of TRUE will be used")
    plot <- T
  }
  if(!is.logical(infer.CDR3)){
    print("Invalid value for infer.CDR3. Default value of FALSE will be used")
    infer.CDR3 <- F
  }
  if(!is.logical(infer.VJ)){
    print("Invalid value for infer.VJ. Default value of FALSE will be used")
    infer.VJ <- F
  }
  if(infer.VJ & use.allele){
    print("infer.VJ=T will not consider allele information on V/J names. use.allele will be set to FALSE")
    use.allele <- F
  }
  if(infer.VJ & use.mouse.strain){
    print("infer.VJ=T will not consider strain information on mouse TRAV names. use.mouse.strain will be set to FALSE")
    use.allele <- F
  }


  if(!plot){
    print("No motif will be generated with plot=FALSE")
  }

  if (is.null(output.path)){
    print("No output.path, results will only be returned in an R list")
    if(plot.all.length){
      print("plot.all.length=T is not supported without output.path. Will be set to FALSE")
      plot.all.length=F
    }
    if(interactive.plots){
      print("interactive.plots=T is not supported without output.path. Will be set to FALSE")
      interactive.plots=F
    }
  } else if(!is.character(output.path) | length(output.path)>1){
    stop("Invalid value for output.path. Should be a single string of character indicating path where to save the plots.")
  }

  if(!is.logical(use.allele)){
    print("Invalid value for use.allele. Default value of FALSE will be used")
    use.allele <- F
  }

  if(!is.logical(correct.gene.names)){
    print("Invalid value for correct.gene.names. Default value of TRUE will be used")
    correct.gene.names <- T
  }
  if(correct.gene.names==F){
    print("Warning: the option to correct V/J names is turned off. You need to be sure all your V/J names follow the IMGT nomenclature")
  }

  if(!is.logical(use.mouse.strain)){
    print("Invalid value for use.mouse.strain. Default value of FALSE will be used")
    use.mouse.strain <- F
  }

  if(!check.cdr3.mode %in% c(0,1,2)){
    print("Invalid value for check.cdr3.mode. Default value of 1 will be used")
    check.cdr3.mode <- 1
  }

  if(!start.lg %in% 0:3){
    print("Invalid value for start.lg. Default value of 1 will be used")
    start.lg <- 1
  }

  if(!end.lg %in% 0:5){
    print("Invalid value for end.lg. Default value of 2 will be used")
    end.lg <- 2
  }
  if(!is.logical(build.clones)){
    print("Invalid value for build.clones. Default value of FALSE will be used")
    build.clones <- F
  }


  if(is.null(renormVJ)){
    renormVJ <- ifelse(is.null(input2),T,F)
  } else {
    if(!is.logical(renormVJ)){
      print(paste("renormVJ=",renormVJ," not supported, default value will be used", sep=""))
      renormVJ <- ifelse(is.null(input2),T,F)
    } else {
      renormVJ <- renormVJ
    }
  }

  if(N.min < 1 | is.numeric(N.min)==FALSE){
    print(paste("N.min=",N.min," not supported, using default N.min=1", sep=""))
    N.min <- 1
  }

  if(!is.na(set.cdr3a.length)){
    if(!is.numeric(set.cdr3a.length) || set.cdr3a.length > Lmax ||
        ((set.cdr3a.length!=-1) && (set.cdr3a.length < Lmin)) ||
        set.cdr3a.length%%1 != 0){
      print(paste("Invalid value for set.cdr3a.length",set.cdr3a.length,". Default value will be used.", sep=""))
      set.cdr3a.length=NA
    }
  }
  if(!is.na(set.cdr3b.length)){
    if(!is.numeric(set.cdr3b.length) || set.cdr3b.length > Lmax ||
        ((set.cdr3b.length!=-1) && (set.cdr3b.length < Lmin) )||
        set.cdr3b.length%%1 != 0){
      print(paste("Invalid value for set.cdr3b.length=",set.cdr3b.length,". Default value will be used.", sep=""))
      set.cdr3b.length=NA
    }
  }

  if(! species.default %in% species.list){
    print("Wrong choice for species.default. Should be either \"HomoSapiens\" or \"MusMusculus\". Default value will be used")
    species.default <- "HomoSapiens"
  }

  if(!is.character(model.default) | length(model.default)>1){
    print(paste("Invalid value for model.default",model.default,". Default value will be used.", sep=""))
    model.default="Model_default"
  }

  if(! verbose %in% 0:3){
    print("Invalid value for verbose. Default value of 1 will be used")
    verbose <- 1
  }



  if(!is.logical(plot.cdr12.motif)){
    print("Invalid value for plot.cdr12.motif. Default value of FALSE will be used")
    plot.cdr12.motif <- F
  }

  if(!plot.oneline %in% c(0,1,2)){
    print("Invalid value for plot.oneline. Default value of 0 will be used")
    plot.oneline <- 0
  }

  if(! plot.cdr3.norm %in% c(0,1,2) ){
    print("Invalid value for plot.cdr3.norm. Default value of 0 will be used")
    plot.cdr3.norm <- 0
  }

  if(! plot.VJ.switch %in% c(1,1.2,1.3,2,2.1)){
    print("Invalid value for plot.VJ.switch. Default value of 1 will be used")
    v$plot.VJ.switch <- 1
  }

  if(!is.logical(label.neg)){
    print("Invalid value for label.neg. Default value of FALSE will be used")
    label.neg <- F
  }

  if(!is.numeric(label.diag) | label.diag<0){
    print("Invalid value for label.diag. Should be a number larger than 0. Default value of 0.3 will be used")
    label.diag <- 0.3
  }

  label.min.fr <- c(label.min.fr.input1, label.min.fr.input2)
  if(!is.numeric(label.min.fr) | length(label.min.fr) != 2 | max(label.min.fr)>1 | min(label.min.fr)<0){
    print("Invalid value for label.min.fr. Default value of 0.05 will be used")
    label.min.fr <- c(0.05,0.05)
  }

  if(! chain %in% c("A","B","AB")){
    print("Invalid value for chain. Default value of \"AB\" will be used")
    chain <- "AB"
  }

  if(! logo.type %in% c("bits", "probability")){
    print("Invalid value for logo.type. Default value of \"bits\" will be used")
    logo.type <- "bits"
  }

  if(!is.character(input1.name)){
    print("Invalid value for input1.name. Default value of \"Input\" will be used")
    input1.name <- "Input"
  }
  if(!is.null(input2.name)){
    if(!is.character(input2.name)){
      print("Invalid value for input2.name. Default value of \"Input2\" will be used")
      input2.name <- "Input2"
    }
  }
  if(!is.null(filename.output)){
    if(!is.character(filename.output)){
      print("Invalid value for filename.output. Default value of the models will be used")
      filename.output <- NULL
    } else {
      if(grepl("\\\\|,|;| |\\*|/|\\?|#", filename.output)){
        filename.output <- gsub("\\\\|,|;| |\\*|/|\\?|#", "_", filename.output)
        print("Special characters, including /, \\, *, space,... are not supported in filename.output. Each of them will be changed into _")
        print(paste("New filename.output:", filename.output))
      }
    }
  }


  if(! output.format %in% c("pdf", "png", "jpg")){
    print("Invalid value for output.format. Default value of \"pdf\" will be used")
    output.format <- "pdf"
  }

  if(!is.logical(print.size)){
    print("Invalid value for print.size. Default value of TRUE will be used")
    print.size <- T
  }


  if(!is.logical(plot.title)){
    print("Invalid value for plot.title. Default value of TRUE will be used")
    plot.title <- T
  }

  if(!is.null(set.title)){
    if(!is.character(set.title) | length(set.title)!=1){
      print("Invalid value for set.title. Model names will be used")
      set.title=NULL
    }
  }

  modelsCombined_name <- "modCombined"
  if (is.character(plot.modelsCombined)){
    if (plot.modelsCombined == ""){
      plot.modelsCombined <- F
    } else {
      modelsCombined_name <- plot.modelsCombined
      plot.modelsCombined <- T
    }
  }
  if (plot.modelsCombined && !(plot.VJ.switch %in% c(2,2.1))){
    warning("plot.modelsCombined is set to TRUE, and plot.VJ.switch wasn't '2' ",
            "or '2.1'. Setting plot.VJ.switch=2 as other VJ plot format is not ",
            "available when combining results from all models in a single plot.")
    plot.VJ.switch <- 2
  }

  ###########
  #Set some specific values for different parameters
  ###########

  keep.gap.pwm <- 0 # 1: means that 'g' (gaps in CDR1/2) are treated as an additional aa in the logos. 0: means that 'g' are treated as unspecific (i.e., 0.05) in the logos
  if(keep.gap.pwm==1){taa.list <- c(aa.list,"g"); additionalAA <- "g"} else {taa.list <- aa.list; additionalAA <- ""}

  min.logo <- 5 #Minimum number of sequences to plot the logos (when plotting different lengths)

  if(plot.oneline>=1){
    th <- theme(plot.title = element_text(size = 8, hjust=0.5), axis.title=element_text(size=4))
  }
  if( !is.null(output.path) ){
    if(!dir.exists(output.path) ){
      dir.create(output.path, recursive = TRUE);
    }
  }

  if(is.null(input2)){
    comp.baseline <- T
    if(is.null(input2.name)){
      baseline.name <- "Baseline"
    } else if(is.character(input2.name)){
      baseline.name <- input2.name
    } else {
      stop("Invalid value for input2.name. Should be a character or NULL")
    }
  } else if(is.character(input2) | is.data.frame(input2) | is.list(input2)) {
    comp.baseline <- F

    if(is.null(input2.name)){
      baseline.name <- "Input2"
    } else if(is.character(input2.name)){
      baseline.name <- input2.name
    } else {
      stop("Invalid value for input2.name. Should be a character or NULL")
    }
  }

  ############################
  # Load all the input data
  ############################
  input1.list=F
  if(is.character(input1)==T){
    if(length(input1)==1){
      if(file.exists(input1)){
        ext <- tail(unlist(strsplit(input1,split=".", fixed=T)), n=1)
        if(ext=="csv"){
          input1 <- read.csv(input1)
        } else if(ext=="txt" | ext=="tsv"){
          input1 <- read.delim(input1, sep="\t", header=T)
        } else if (ext=="rds"){
          input1 <- readRDS(input1)
          input1.list <- T
        } else {
          stop("Invalid file format for input2")
        }
      } else {
        stop("Missing file for input1")
      }
    } else {
      stop("Invalid input1. If using a filename, it should be a single file. If using data, make sure it is a dataframe with the required fields")
    }
  } else if(is.data.frame(input1)==T){
    input1 <- as.data.frame(input1)
    # Use as.data.frame because a tibble is also a data.frame but some of the
    # code has issues if input is a tibble instead of "simpler" data.frame (due
    # to column indexing by a single column that keep it as a tibble while it is
    # transforming it to a vector if a data.frame).
  } else if(is.list(input1)){
    input1.list <- T
  } else {
    stop("Invalid value for input1. Should be a .csv or tab delimited .txt filename or a data.frame or a list generated by MixTCRviz")
  }

  if(!input1.list){

    # Check the compatibility between chain and the actual data.
    # If not compatible, try correcting chain. If impossible, stop the run
    chain <- verify.chain(input=input1, chain=chain)
    if(chain==""){
      stop("Incompatibilities between the data and chain parameter, and unable to infer the chain... check your input and the chain parameter")
    }
  }

  if(chain=="A"){
    chain.list <- c("TRA");
    set.cdr3.length <- c(set.cdr3a.length)
  } else if(chain=="B"){
    chain.list <- c("TRB");
    set.cdr3.length <- c(set.cdr3b.length)
  } else if(chain=="AB"){
    chain.list <- c("TRA","TRB");
    set.cdr3.length <- c(set.cdr3a.length, set.cdr3b.length)
  }
  names(set.cdr3.length) <- chain.list

  # Check the input
  cat("\n####\nChecking input1:\n")
  check <- check_input(input=input1, chain = chain, name="input1", infer.VJ=infer.VJ, infer.CDR3=infer.CDR3,
                       species.default = species.default, model.default = model.default,
                       input.list=input1.list, build.clones=build.clones)
  input1 <- check$data
  #map.back.colnames <- check$col.map

  if(!input1.list){

    if(infer.VJ){
      input1 <- inferVJ(input1, chain=chain, species.default = species.default, verbose=verbose)
    }
    if(infer.CDR3){
      input1 <- inferCDR3(input1, chain=chain, species.default = species.default, verbose=verbose)
    }

    input1 <- clean_input(input=input1, use.allele=use.allele, correct.gene.names = correct.gene.names,
                          use.mouse.strain = use.mouse.strain, chain = chain, keep.incomplete.chain = keep.incomplete.chain,
                          species.default = species.default, check.cdr3.mode = check.cdr3.mode, start.lg=start.lg, end.lg=end.lg,
                          seq.protocol=seq.protocol, verbose=verbose)
  }

  #############
  # Load input2
  #############

  if(!comp.baseline){
    input2.list <- F
    if(is.character(input2)){
      if(file.exists(input2)){
        ext <- tail(unlist(strsplit(input2,split=".", fixed=T)), n=1)
        if(ext=="csv"){
          input2 <- read.csv(input2)
        }else if(ext=="txt" | ext=="tsv"){
          input2 <- read.delim(input2, sep="\t", header=T)
        } else if (ext=="rds"){
          input2 <- readRDS(input2)
          input2.list <- T
        } else {
          stop("Invalid file format for input2")
        }
      } else {
        stop("Missing file for input2")
      }
    } else if(is.data.frame(input2)){
      input2 <- as.data.frame(input2)
      # See comment for input1
    } else if(is.list(input2)){
      input2.list <- T
    } else {
      stop("Invalid value for input2. Should be a .csv filename or a data.frame")
    }
    cat("####\nChecking input2:\n")

    if(!input2.list){
      if(length(unique(input2$model))>1){
        stop("Issues with 'model' column in input2. All entries should have the same value.")
      }
      ch <- verify.chain(input=input2, chain=chain)
      if(ch != chain){
        stop("Incompatible chains between input1 and input2")
      }
    }
    input2 <- check_input(input=input2, chain=chain, name="input2", infer.VJ=infer.VJ, infer.CDR3=infer.CDR3,
                          species.default = species.default, model.default = model.default, input.list=input2.list, build.clones=build.clones())$data
    if(!input2.list){

      if(infer.VJ){
        input2 <- inferVJ(input2, chain=chain, species.default = species.default, verbose=verbose)
      }
      if(infer.CDR3){
        input2 <- inferCDR3(input2, chain=chain, species.default = species.default, verbose=verbose)
      }
      input2 <- clean_input(input=input2, use.allele = use.allele, correct.gene.names = correct.gene.names,
                            use.mouse.strain = use.mouse.strain, chain = chain, keep.incomplete.chain = keep.incomplete.chain,
                            species.default = species.default, check.cdr3.mode = check.cdr3.mode, start.lg=start.lg, end.lg=end.lg,
                            seq.protocol=seq.protocol, verbose=verbose)
    }
  }

  ########################
  #Select the models which should be considered
  ########################

  #Take samples where there is at least one chain with enough data
  if(!input1.list){
    if (is.factor(input1$model)){
      md <- levels(input1$model)
      # When this model is given as a factor, we keep its order (this is useful
      # only for the plot.modelsCombined=TRUE option, to have the models in this
      # order instead of 'random' order).
    } else {
      md <- unique(input1[,"model"])
    }
    st <- lapply(md, function(x){
      i <- which(input1[,"model"]==x);
      nA <- length(which(!is.na(input1[i,"TRAV"]) | !is.na(input1[i,"TRAJ"]) | !is.na(input1[i,"cdr3_TRA"]) ))
      nB <- length(which(!is.na(input1[i,"TRBV"]) | !is.na(input1[i,"TRBJ"]) | !is.na(input1[i,"cdr3_TRB"]) ))
      if( (nA>=N.min & chain=="A") | (nB>=N.min & chain=="B") | ((nA>=N.min | nB>=N.min) & chain=="AB")){
        return(1)
      } else {
        warning("Model ",x," will not be considered (less than N.min=", N.min," data)")
        return(0)
      }
    })
    model.list <- md[st==1]
  } else {
    model.list <- c(input1$model) #In this case, only one model is allowed
  }
  if(length(model.list)==0){
    stop("No model has enough data to use MixTCRviz. Check your input, or the N.min parameter if you set it manually.")
  }
  if(length(model.list)>1 & !is.null(filename.output) & !is.null(output.path)){
    stop("filename.output should not be used in the presence of multiple models in input1, since files will overwrite each other. Leave it to NULL")
  }


  #######################################
  # Analyse the input
  #######################################

  comb_res <- list()
  plot.lst <- list()
  es.lst <- list()
  if(!input1.list){
    input1.lst <- list()
  } else {
    if(verbose>0){
      print("Will not be able to return processed data for input1 since it does not contain raw data.")
    }
  }

  for (ch in chain.list){
    if (!is.na(set.cdr3.length[ch]) && (set.cdr3.length[ch] == -1)){
      # When this is "-1" we determine the most common length among all the
      # models that are kept for the figures, to have the a same CDR3 length
      # showed.
      lTab <- table(nchar(input1[input1$model %in% model.list, paste0("cdr3_",ch)]))
      set.cdr3.length[ch] <- as.numeric(names(which.max(lTab)))
    }
  }

  # Will be used when plot.modelsCombined=TRUE to store values from each model.
  for(model in model.list){

    use.allele.es <- use.allele

    if(!is.null(filename.output)){
      filename.final <- filename.output
    } else {
      filename.final <- model
      if(grepl("\\\\|,|;| |\\*|/|\\?|#", filename.final)){
        filename.final <- gsub("\\\\|,|;| |\\*|/|\\?|#", "_", filename.final)
        print("Special characters, including /, \\, *, space,... are not supported in filenames derived from 'model'. Each of them will be changed into _")
        print(paste("New filename :", filename.final))
      }
    }


    print(paste("Model:",model))

    pg.all <- list()
    interactive_figure <- list()
    pg.length <- list()
    tl.logo <- list() #Keep track of the number of logos of different length

    if(!input1.list){
      input1.es <- input1[which(input1[,"model"]==model),]
      species <- unique(input1.es[,"species"])
      if(length(species)>1){
        stop("Multiple species provided for the same model. Use a different model name for each species")
      } else {
        if(species %in% species.list==F){
          stop(paste("Unknown species: ",sp,". MixTCRviz supports only \"HomoSapiens\" or \"MusMusculus\"", sep=""))
        }
      }
      if(species=="MusMusculus" & use.allele.es){
        print("Alleles currently not supported in mouse. The data will be treated at the gene level")
        use.allele.es <- F
      }

      es <- build_stat(input1.es, chain=chain, species=species, comp.VJL=0)
      es$model <- model

      input1.lst[[model]] <- input1.es


    } else {
      es <- input1
      species <- input1$species
    }
    es.lst[[model]] <- es



    if(output.stat){
      dir <- paste(output.path,"/stats/", sep="")
      if(!dir.exists(dir)){
        dir.create(dir);
      }
      saveRDS(es, file=paste(output.path,"/stats/",filename.final,".rds", sep=""))
    }
    if(output.processed.data){
      if(!input1.list){
        dir <- paste(output.path,"/processed_data/", sep="")
        if(!dir.exists(dir)){
          dir.create(dir);
        }
        tinput1.es <- input1.es

        quote_if_comma <- function(x) {  ifelse(grepl(",", x), paste0('"', x, '"'), x) }
        tinput1.es <- as.data.frame(lapply(tinput1.es, function(col) { if (is.character(col)) quote_if_comma(col) else col }))

        write.csv(tinput1.es, file=paste(output.path,"/processed_data/",filename.final,".csv", sep=""), quote=F, row.names = F, na = "")
      }
    }

    if(plot){

      if(comp.baseline){

        #####
        # Load the baseline repertoire corresponding to the species
        #####
        if(is.null(baseline)){
          #These are the default repertoires.
          if(species=="HomoSapiens"){
            if(use.allele.es){
              baseline.model <-  MixTCRviz::baseline_HomoSapiens_allele
            } else {
              baseline.model <- MixTCRviz::baseline_HomoSapiens
            }
          }
          if(species=="MusMusculus"){
            if(!use.allele.es){  #N.B. Currently always the case in mouse
              if(use.mouse.strain){
                baseline.model <- MixTCRviz::baseline_MusMusculus_Strain
              } else {
                baseline.model <- MixTCRviz::baseline_MusMusculus
              }
            }
          }
        } else if(is.character(baseline)) {
          if(baseline=="SEQTR"){
            if(use.allele==T){
              print("SEQTR is used as baseline, alleles will be discarded")
              use.allele <- F
            }


            if(species=="HomoSapiens"){
              baseline.model <- MixTCRviz::baseline_HomoSapiens_SEQTR
            } else if(species=="MusMusculus"){
              stop("SEQTR baseline not available in mouse")
              #if(use.mouse.strain){
              #  baseline.model <- MixTCRviz::baseline_MusMusculus_Strain_SEQTR
              #} else{
              #  baseline.model <- MixTCRviz::baseline_MusMusculus_SEQTR
              #}
            }
          } else if(baseline=="Default"){
            if(species=="HomoSapiens"){
              if(use.allele){
                baseline.model <- MixTCRviz::baseline_HomoSapiens_allele
              } else {
                baseline.model <- MixTCRviz::baseline_HomoSapiens
              }
            } else if(species=="MusMusculus"){
              if(use.mouse.strain){
                baseline.model <- MixTCRviz::baseline_MusMusculus_Strain
              } else {
                baseline.model <- MixTCRviz::baseline_MusMusculus
              }
            }
          } else if(file.exists(baseline)){
            st <- strsplit(baseline, split=".", fixed = T)[[1]]
            if(st[length(st)]=="rds"){
              baseline.model <- readRDS(file=baseline)
            } else if(st[length(st)]=="rda" | st[length(st)]=="rdata"){
              load(baseline.model)
            } else{
              stop("Unsupported format for baseline file. Should be .rds, .rda or .rdata")
            }
            #Here we should have a way to check the baseline data...
          } else {
            stop("Missing baseline file")
          }
        } else if (is.list(baseline)){
          baseline.model <- baseline
        } else {
          stop("Unable to use the baseline provided in input")
        }

      } else {

        #####
        # Load the other repertoire to compare with
        #####
        if (plot.modelsCombined){
          stop("The plot.modelsCombined isn't implemented for comparisons with ",
               "additional input2 data instead of a baseline repertoire.")
        }
        if(!input2.list){
          baseline.model <- build_stat(input2, chain=chain, species=species, comp.VJL=renormVJ)
        } else {
          baseline.model <- input2

          if(input2$species != species){
            stop(paste("Different species between input1 (",model,") and input2.", sep=""))
          }
        }
      }

      for(ch in chain.list){

        #print(ch)

        if(comp.baseline){
          #Check segments that were in the ES, but not in baseline
          miss.V.baseline <- setdiff(names(es$countV[[ch]]), names(baseline.model$countV[[ch]]))
          miss.J.baseline <- setdiff(names(es$countJ[[ch]]), names(baseline.model$countJ[[ch]]))
          if(verbose>0){
            if(length(miss.V.baseline)>=1){
              print(paste("WARNING: ",ch,"V in Input TCRs, but absent from baseline: ", sep=""))
              print(miss.V.baseline)
            }
            if(length(miss.J.baseline)>=1){
              print(paste("WARNING: ",ch,"J in Input TCRs, but absent from baseline: ", sep=""))
              print(miss.J.baseline)
            }
          }
        }

        if(verbose>0){
          if(length(es$countL[[ch]])==0){
            print(paste("WARNING: No CDR3", chain.small[ch]," segment in input1", sep=""))
          }
          if(length(es$countV[[ch]])==0){
            print(paste("WARNING: No ", ch,"V segment in input1", sep=""))
          }
          if(length(es$countJ[[ch]])==0){
            print(paste("WARNING: No ",ch,"J segment in input1", sep=""))
          }

          if(!comp.baseline){
            if(length(baseline.model$countL[[ch]])==0){
              print(paste("WARNING: No CDR3", chain.small[ch]," segment in input2", sep=""))
            }
            if(length(baseline.model$countV[[ch]])==0){
              print(paste("WARNING: No ", ch,"V segment in input2", sep=""))
            }
            if(length(baseline.model$countJ[[ch]])==0){
              print(paste("WARNING: No ",ch,"J segment in input2", sep=""))
            }
          }
        }

        #######
        # Plot length distribution
        #######

        if(length(es$countL[[ch]])>0 & length(baseline.model$countL[[ch]])>0){
          info <- c(chain.small[ch], input1.name, baseline.name, model)
          names(info) <- c("chain", "input1.name", "baseline.name", "model")
          if(print.size){
            info["input1.name"] <- paste(info["input1.name"], " (", sum(es$countL[[ch]]),")",sep="")

            if(!comp.baseline){
              info["baseline.name"] <- paste(info["baseline.name"], " (", sum(baseline.model$countL[[ch]]),")",sep="")
            }
          }

          if(renormVJ==1){
            if(length(es$countVJ[[ch]])>0 & !is.null(baseline.model$countL.VJ[[ch]])){
              info["baseline.name"] <- paste(info["baseline.name"], "P(VJ)",sep=" | ")
              bs <- weighted_countL(baseline.model$countL.VJ[[ch]], es$countVJ[[ch]])

            } else {
              if(length(es$countVJ[[ch]])==0){
                print(paste("No P(VJ) information in input1 to compute baseline CDR3",chain.small[ch]," length distribution | P(VJ). renormVJ=0 will be used", sep=""))
              }
              if(is.null(baseline.model$countL.VJ[[ch]])){
                print(paste("No P(L|VJ) information in baseline/input2 to compute baseline CDR3",chain.small[ch]," length distribution | P(VJ). renormVJ=0 will be used", sep=""))
              }
              bs <- baseline.model$countL[[ch]]
            }
          } else{
            bs <- baseline.model$countL[[ch]]
          }
          bs.sd <- baseline.model$sdL[[ch]] # This means that we do not change the sd values, irrespective of | P(VJ)

          #baseline.model$sdL[[ch]] <- 0.2*baseline.model$countL[[ch]]/sum(baseline.model$countL[[ch]])
          #es$sdL[[ch]] <- 0.2*es$countL[[ch]]

          ld.plot <- plotLD(es$countL[[ch]], bs, info=info, sd.es=es$sdL[[ch]], sd.rep=bs.sd, plot.oneline=plot.oneline,
                            ret.resList=plot.modelsCombined, comp.baseline=comp.baseline, print.size=print.size, plot.sd=plot.sd)
        } else {
          ld.plot <- ggplot()
        }

        #######
        # Plot comparison of V/J usage
        #######

        if(length(es$countV[[ch]])>0 & length(baseline.model$countV[[ch]])>0){

          infoV <- c(paste(ch,"V", sep=""), input1.name, baseline.name, model)
          names(infoV) <- c("gene", "input1.name", "baseline.name", "model")

          countV.plot <- plotVJ(count.es=es$countV[[ch]], count.rep=baseline.model$countV[[ch]],
                                sd.es=es$sdV[[ch]], sd.rep=baseline.model$sdV[[ch]],
                                distr.es=es$distrV[[ch]], distr.rep=baseline.model$distrV[[ch]],
                                info=infoV, comp.baseline=comp.baseline, pType=plot.VJ.switch, species=species,
                                ZscoreVJ.thresh=ZscoreVJ.thresh, FoldChangeVJ.thresh=FoldChangeVJ.thresh,
                                ret.resList=plot.modelsCombined, label.neg = label.neg, label.diag=label.diag, label.min.fr=label.min.fr, print.size=print.size, plot.sd=plot.sd, verbose=verbose)
        } else {
          #This happens if the baseline is empty for one chain
          countV.plot <- ggplot()
        }

        if(length(es$countJ[[ch]])>0 & length(baseline.model$countJ[[ch]])>0){

          infoJ <- c(paste(ch,"J", sep=""), input1.name, baseline.name, model)
          names(infoJ) <- c("gene", "input1.name", "baseline.name", "model")


          countJ.plot <- plotVJ(count.es=es$countJ[[ch]], count.rep=baseline.model$countJ[[ch]],
                                sd.es=es$sdJ[[ch]], sd.rep=baseline.model$sdJ[[ch]],
                                distr.es=es$distrJ[[ch]], distr.rep=baseline.model$distrJ[[ch]],
                                info=infoJ, comp.baseline=comp.baseline, pType=plot.VJ.switch, species=species,
                                ZscoreVJ.thresh=ZscoreVJ.thresh, FoldChangeVJ.thresh=FoldChangeVJ.thresh,
                                ret.resList=plot.modelsCombined, label.neg = label.neg, label.diag=label.diag, label.min.fr=label.min.fr, print.size=print.size, plot.sd=plot.sd, verbose=verbose)
        } else {
          countJ.plot <- ggplot()
        }

        #######
        # Plot comparison of motifs for CDR1 and CDR2, but this is redundant with V/J plots
        # No correction based on VJ usage
        #######

        logo <- list()

        if(plot.cdr12.motif){
          if (plot.modelsCombined){
            stop("The plot.modelsCombined isn't implemented for CDR1/2 motifs.")
          }

          if(length(es$countV[[ch]])>0){

            for(cdr in c("CDR1", "CDR2")){
              lc <- paste("L",nchar(cdr123[[species]][[ch]][1,cdr]),sep="_")  #Check the length of cdr1 and cdr2
              if(cdr=="CDR1"){
                ct <- es$countCDR1[[ch]][[lc]];
                ylab <- ""; ylab.baseline <- ""
              }
              if(cdr=="CDR2"){
                ct <- es$countCDR2[[ch]][[lc]];
                ylab <- ""; ylab.baseline <- ""
              }
              pwm <- build_cdr12_motif(ct, keep.gap=keep.gap.pwm)  #Useful if we keep the gaps
              logo1 <- ggseqlogoMOD::ggseqlogoMOD(data=pwm, additionaAA=additionalAA, axisTextSizeX = 10, axisTextSizeY = 10) +
                ggtitle(paste(cdr,chain.small[ch]," ",input1.name," (", sum(es$countV[[ch]]),")",sep="")) + ylab(ylab) + th + theme(plot.title=element_text(size=12))
              #pwm2 <- build_cdr12_motif(ct2, keep.gap=keep.gap.pwm)
              #logo2 <- ggseqlogoMOD::ggseqlogoMOD(data=pwm2, additionaAA=additionalAA,  axisTextSizeX = 10, axisTextSizeY = 10) +
              #ggtitle(paste(cdr,chain.small[ch]," ",baseline.name," ", sep="")) + ylab(ylab.baseline) + th + theme(plot.title=element_text(size=12))
              #logo[[cdr]] <- ggarrange(logo1, logo2, nrow=2)
              logo[[cdr]] <- ggarrange(logo1, nrow=1)

            }

          } else {
            for(cdr in c("CDR1", "CDR2")){
              logo[[cdr]] <- ggplot()
            }
          }
        }

        #######
        # Plot comparison of motifs of CDR3 for specific lengths
        #######

        if(length(es$countL[[ch]])>0){

          #Take the length with max Input TCRs
          info <- c(chain.small[ch], input1.name, baseline.name, model)
          names(info) <- c("chain", "input1.name", "baseline.name", "model")

          #Here we include a correction based on VJ usage for each length.
          if(renormVJ==1){
            if(max(sapply(es$countVJ.L[[ch]],length))>0 & !is.null(baseline.model$countCDR3.VJL[[ch]])){  #Make sure we have V-J pairs for at least one length
              info["baseline.name"] <- paste(info["baseline.name"], "P(VJ)",sep=" | ")
              bs <- weighted_countCDR3(baseline.model$countCDR3.VJL[[ch]], es$countVJ.L[[ch]])
            } else {
              if(max(sapply(es$countVJ.L[[ch]],length))==0){
                print(paste("No P(VJ|L) information in input1 to compute baseline CDR3",chain.small[ch]," motif | P(VJ). renormVJ=0 will be used",sep=""))
              }
              if(is.null(baseline.model$countCDR3.VJL[[ch]])){
                print(paste("No P(CDR3|VJL) information in baseline/input2 to compute baseline CDR3",chain.small[ch]," motif | P(VJ). renormVJ=0 will be used",sep=""))
              }
              bs <- baseline.model$countCDR3.L[[ch]]
            }
          } else {
            bs <- baseline.model$countCDR3.L[[ch]]
          }
          CDR3 <- plotCDR3(countL.es=es$countL[[ch]], countL.rep=baseline.model$countL[[ch]],
                           countCDR3.es=es$countCDR3.L[[ch]], countCDR3.rep=bs, logo.type=logo.type,
                           info=info, comp.baseline=comp.baseline, plot.oneline=plot.oneline, plot.all.length=plot.all.length,
                           plot.cdr3.subtract.baseline=plot.cdr3.norm, set.cdr3.length=set.cdr3.length[[ch]],
                           print.size=print.size)

          logo.CDR3.L.es <- CDR3$ES
          logo.CDR3.L.baseline <- CDR3$Baseline

          if(length(CDR3$length)>0){
            L.inter <- paste("L",CDR3$length, sep="_")
          } else {L.inter <- c()}

          lmax <- CDR3$lmax

          if (!plot.modelsCombined){
            logo[["CDR3"]] <- ggarrange(CDR3$ES_max, CDR3$Baseline_max, nrow=2)

            if(length(es$countVJ.L[[ch]][[paste("L",lmax,sep="_")]])==0){
              print(paste("No P(VJ|L) information in input1 to compute baseline CDR3 | P(VJ) for Lmax=",lmax,". Empty motif will be shown.",sep=""))
              print("  This is typically due to many entries missing V or J information, or wrong V/J names which could not be corrected")
            }
          } else {
            CDR3$ES_max$labels$title <- paste0(model, " - ", CDR3$ES_max$labels$title)
          }
        } else {
          logo.CDR3.L.es <- NULL
          logo.CDR3.L.baseline <- NULL
          CDR3 <- NULL
          logo[["CDR3"]] <- ggplot()
        }

        #############
        #Build the full Figure (or save intermediate results for plot.modelsCombined)
        #############

        if (!plot.modelsCombined){
          if(plot.cdr12.motif){
            g <- ggarrange(countV.plot, countJ.plot, ld.plot, ncol=3)
            pg.cdr12 <- ggarrange(logo[["CDR1"]], logo[["CDR2"]], ncol=2)
            pg.all[[ch]] <- ggarrange(g, ggarrange(pg.cdr12, CDR3$ES_max, ncol=2, widths=c(1.2,1)), heights=c(1.5,1), nrow=2)
          } else {
            if(plot.oneline==0){
              pg.all[[ch]] <- ggarrange(countV.plot, countJ.plot, ld.plot, logo[["CDR3"]], ncol=2, nrow=2)
            } else if(plot.oneline==1){
              pg.all[[ch]] <- ggarrange(countV.plot, countJ.plot, ld.plot, logo[["CDR3"]], ncol=4, nrow=1)
            } else if(plot.oneline==2){
              pg.all[[ch]] <- ggarrange(countV.plot, countJ.plot, ld.plot, ncol=3, nrow=1)
            }
          }
          if(interactive.plots){
            interactive_figure[[ch]] <- create_interactive_plots(countV.plot,countJ.plot,ld.plot,CDR3,plot.oneline)
          }
        } else {
          # Combine data from current model with data from previous models
          comb_res[[species]][[ch]]$V$count.df <- dplyr::bind_rows(
            comb_res[[species]][[ch]]$V$count.df, countV.plot$count.df)
          comb_res[[species]][[ch]]$V$segment <- union(
            comb_res[[species]][[ch]]$V$segment, countV.plot$segment)
          comb_res[[species]][[ch]]$V$namesToKeep <- union(
            comb_res[[species]][[ch]]$V$namesToKeep, countV.plot$namesToKeep)
          comb_res[[species]][[ch]]$J$count.df <- dplyr::bind_rows(
            comb_res[[species]][[ch]]$J$count.df, countJ.plot$count.df)
          comb_res[[species]][[ch]]$J$segment <- union(
            comb_res[[species]][[ch]]$J$segment, countJ.plot$segment)
          comb_res[[species]][[ch]]$J$namesToKeep <- union(
            comb_res[[species]][[ch]]$J$namesToKeep, countJ.plot$namesToKeep)
          comb_res[[species]][[ch]]$ld$ld.df <- dplyr::bind_rows(
            comb_res[[species]][[ch]]$ld$ld.df, ld.plot$ld.df)
          comb_res[[species]][[ch]]$ld$info <- union(
            comb_res[[species]][[ch]]$ld$info, ld.plot$info)
          comb_res[[species]][[ch]]$CDR3[[model]] <- CDR3$ES_max
        }


        if(plot.all.length){
          if (plot.modelsCombined){
            stop("The plot.modelsCombined isn't implemented to show the ",
                 "results from various CDR3 lengths.")
          }

          tl.logo[[ch]] <- intersect(names(es$countL[[ch]][es$countL[[ch]]>=min.logo]), L.inter) #Currently the min.logo limitation does not apply to L.inter

          if(length(tl.logo[[ch]])>0){
            logo.sub <- list()
            logo.sub.baseline <- list()

            plotVJ.L <- list()
            ct <- 1
            for(t in tl.logo[[ch]]){
              logo.sub[[ct]] <- logo.CDR3.L.es[[t]]
              logo.sub.baseline[[ct]] <- logo.CDR3.L.baseline[[t]]

              #Add the comparison of V/J usage
              infoV <- c(paste(ch,"V", sep=""), input1.name, paste0(baseline.name, " | L"), model)
              names(infoV) <- c("gene", "input1.name", "baseline.name", "model")
              plotV.L <- plotVJ(count.es=es$countV.L[[ch]][[t]], count.rep=baseline.model$countV.L[[ch]][[t]],
                                sd.es=es$sdV.L[[ch]][[t]], sd.rep=baseline.model$sdV.L[[ch]][[t]],
                                distr.es=es$distrV.L[[ch]], distr.rep=baseline.model$distrV.L[[ch]],
                                ZscoreVJ.thresh=ZscoreVJ.thresh, FoldChangeVJ.thresh=FoldChangeVJ.thresh,
                                info=infoV, comp.baseline = comp.baseline, pType=plot.VJ.switch, species=species, label.neg = label.neg,  label.diag=label.diag,
                                label.min.fr=label.min.fr, print.size=print.size, verbose=verbose)
              infoJ <- c(paste(ch,"J", sep=""), input1.name, paste0(baseline.name, " | L"), model)
              names(infoJ) <- c("gene", "input1.name", "baseline.name", "model")
              plotJ.L <- plotVJ(count.es=es$countJ.L[[ch]][[t]], count.rep=baseline.model$countJ.L[[ch]][[t]],
                                sd.es=es$sdJ.L[[ch]][[t]], sd.rep=baseline.model$sdJ.L[[ch]][[t]],
                                distr.es=es$distrJ.L[[ch]], distr.rep=baseline.model$distrJ.L[[ch]],
                                ZscoreVJ.thresh=ZscoreVJ.thresh, FoldChangeVJ.thresh=FoldChangeVJ.thresh,
                                info=infoJ, comp.baseline = comp.baseline, pType=plot.VJ.switch, species=species, label.neg = label.neg,  label.diag=label.diag,
                                label.min.fr=label.min.fr, print.size=print.size, verbose=verbose)

              plotVJ.L[[ct]] <- ggarrange(plotV.L, plotJ.L, ncol=2, nrow=1)

              ct <- ct+1

            }
            g1 <- ggarrange(plotlist=plotVJ.L, nrow=length(tl.logo[[ch]]), ncol=1)
            g2 <- ggarrange(plotlist=logo.sub, nrow=length(tl.logo[[ch]]), ncol=1)
            g3 <- ggarrange(plotlist=logo.sub.baseline, nrow=length(tl.logo[[ch]]), ncol=1)

            pg.length[[ch]] <- ggarrange(plotlist=list(g1,g2,g3), nrow=1, ncol=3)


          } else {
            tl.logo[[ch]] <- c()
            pg.length[[ch]] <- ggplot()
          }

        }
        #End of the part specific for plotting data

        #} else {
        #  #This is the case where no CDR3 is given
        #  pg.all[[ch]] <- ggplot()
        #  pg.length[[ch]] <- ggplot()
        #  tl.logo[[ch]] <- c()
        #
        #  print(paste("WARNING: No CDR3",chain.small[ch]," data in input1", sep=""))
        #}
      } #End of the loop over both chains


      if (!plot.modelsCombined){
        if(chain=="A" | chain=="B"){
          pg.both <- pg.all[[chain.list[1]]]; div=2
          if(interactive.plots){
            combined_both<- interactive_figure[[chain.list[1]]]
          }
        }
        if(chain=="AB"){
          pg.both <- ggarrange(pg.all[[chain.list[1]]], pg.all[[chain.list[2]]], ncol=2); div=1

          if(interactive.plots){
            combined_both<- manipulateWidget::combineWidgets(
              interactive_figure[[chain.list[1]]] , interactive_figure[[chain.list[2]]],
              ncol = 2,
              title = NULL
            )


          }
        }

        if(!is.null(set.title)){
          title.final <- set.title
        } else {
          title.final <- model
        }
        if(plot.title){
          spacer.size=0.02
          spacer <- ggplot() + theme_void() + theme(plot.margin = unit(c(1, 0, 0, 0), "cm"))
          fig <- ggarrange(spacer, pg.both, ncol=1, nrow=2, heights=c(spacer.size,1))

          fig <- annotate_figure(fig, top = text_grob(label=title.final, face = "bold", size = 16))

          fig <- ggarrange(spacer, fig,ncol=1, nrow=2, heights=c(spacer.size,1))
        } else {
          fig <- pg.both
        }

        if(plot.cdr12.motif){
          width <- 20
          height <- 6
        } else {
          if(plot.oneline==0){
            width <- 15
            height <- 8
            desired_width <- "100%"
            style_width <- "auto"
            desired_height <- "100%"
          } else if(plot.oneline==1){
            width <- 20
            height <- 3
            desired_width <- "2500px"
            style_width <- "auto"
            desired_height <- "400px"
          } else if(plot.oneline==2){
            width <- 15
            height <- 3
            desired_width <- "2500px"
            style_width <- "auto"
            desired_height <- "400px"

          }
          if(chain=="A" | chain=="B"){
            if(plot.oneline==0){
              desired_width <- "100%"
              style_width <- "50%"
              desired_height <- "100%"
            }else if(plot.oneline==1){
              desired_width <- "1250px"
              style_width <- "75%"
              desired_height <- "400px"
            }else if(plot.oneline==2){
              desired_width <- "1200px"
              style_width <- "70%"
              desired_height <- "400px"
            }

          }
        }
        if(!is.null(output.path)){
          ggsave(fig, filename=paste(output.path,"/",filename.final,".", output.format, sep=""), device=output.format, width = width/div, height = height)
        }
        plot.lst[[model]] <- fig

        if(interactive.plots){

          # Create JavaScript code with simple string concatenation
          if(!is.null(set.title)){
            ttl <- set.title
          } else {
            ttl <- model
          }
          if(!plot.title){
            ttl <- ""
          }
          js_code <- paste0(
            "
              function(el, x) {
                var parentDiv = el.parentNode;

                // Style for the title
                var titleDiv = document.createElement('div');
                titleDiv.innerHTML = '", ttl, "';
                titleDiv.style.textAlign = 'center';
                titleDiv.style.fontSize = '24px';
                titleDiv.style.fontWeight = 'bold';
                titleDiv.style.position = 'fixed';
                titleDiv.style.top = '20px';
                titleDiv.style.width = '100%';
                titleDiv.style.backgroundColor = 'white';
                titleDiv.style.zIndex = '1000';
                titleDiv.style.padding = '10px 0';
                document.body.insertBefore(titleDiv, document.body.firstChild);

                // Adjust the parent div of the widget
                parentDiv.style.overflowX = 'auto'; // Add horizontal scroll
                parentDiv.style.overflowY = 'hidden'; // Disable vertical scroll
                parentDiv.style.width = '", style_width, "'; // Set parent div width to less than full width to see margin effect
                parentDiv.style.margin = '50px auto 0 auto'; // Center horizontally with automatic margins and add top margin for title
                el.style.display = 'inline-block'; // Set widget to inline-block to prevent squeezing
                el.style.width = '", desired_width, "'; // Adjust this width to allow enough room for the plots
                el.style.height = '", desired_height, "';  // Height for better visibility
              }
            "
          )

          html_file <-paste(output.path,"/",filename.final,".html", sep="")

          scrollable_combined_figure <- htmlwidgets::onRender(
            combined_both,
            js_code
          )
          htmlwidgets::saveWidget(scrollable_combined_figure, file = html_file, selfcontained = TRUE)

          # Get the name of the folder that may have been created
          folder_name <- sub(".html$", "_files", html_file)

          # Delete the folder if it exists
          if (dir.exists(folder_name)) {
            unlink(folder_name, recursive = TRUE)
          }
        }
        if(plot.all.length){
          dir.length <- paste(output.path,"/CDR3_length/", sep="")
          if(!dir.exists(dir.length)){
            dir.create(dir.length);
          }

          for(ch in chain.list){
            g.final <- pg.length[[ch]];
            mx <- length(tl.logo[[ch]])
            if(mx>0){
              if(!is.null(output.path)){
                ggsave(g.final, filename=paste(dir.length, model,"_",ch,".", output.format, sep=""), device=output.format, width = 20, height = 2.5*mx)
              }
            }
          }
        }
      }
    }
  }
  if (plot.modelsCombined && plot){

    # First, a little test to see if there seem to be inconsistencies between
    # the various models in the sense that some descriptors weren't the same.
    purrr::iwalk(comb_res, .f=function(resSp, species){
      purrr::iwalk(resSp, .f=function(resCh, ch){
        purrr::walk2(c("V", "J", "ld"), c("gene", "gene", "info"), .f=function(x, y){
          if (length(resCh[[x]][[y]]) > 1){
            stop(paste0("The length of comb_res[[", species, "]][[", ch, "]][[",
                        x, "]][[", y, "]] seems inconsistent, having more than 1 value ",
                        "after combining models."))
          }
        })
      })
    })

    purrr::iwalk(comb_res, .f=function(resSp, species){
      # The 1st level of comb_res is the species. We'll make separate plot
      # per species as there aren't the same genes.
      for (ch in chain.list){
        # The 2nd level of comb_res is the chain.
        ld.plot <- plotLD(combined.resList=resSp[[ch]]$ld)
        countV.plot <- plotVJ(pType=plot.VJ.switch, species=species,
                              combined.resList=resSp[[ch]]$V, verbose=verbose)
        countJ.plot <- plotVJ(pType=plot.VJ.switch, species=species,
                              combined.resList=resSp[[ch]]$J, verbose=verbose)
        CDR3_logos <- ggarrange(plotlist=resSp[[ch]]$CDR3, ncol=1)

        VJ.plot <- ggarrange(countV.plot, countJ.plot, nrow=1,
                             common.legend=T, legend="right")
        # We arrange them together, keeping a single legend as it's the same.
        ld_CDR3logo_plot <- ggarrange(ld.plot, CDR3_logos, nrow=1)

        if(plot.oneline==0){
          pg.all[[ch]] <- ggarrange(VJ.plot, ld_CDR3logo_plot, nrow=2,
                                    heights=c(1.3, 1))
          # Make that bar plots are slightly bigger than CDR3 ld and motif.
        } else if(plot.oneline==1){
          pg.all[[ch]] <- ggarrange(VJ.plot, ld_CDR3logo_plot, nrow=1)
        } else if(plot.oneline==2){
          pg.all[[ch]] <- ggarrange(VJ.plot, ld.plot, nrow=1, widths=c(2, 1))
        }
      }

      if(chain=="A" | chain=="B"){   pg.both <- pg.all[[chain.list[1]]]; div=2   }
      if(chain=="AB"){  pg.both <- ggarrange(pg.all[[chain.list[1]]], pg.all[[chain.list[2]]], ncol=2); div=1  }

      fig <- pg.both
      nModels_sp <- max(purrr::map_int(resSp, ~length(.x$CDR3)))

      if(plot.oneline==0){
        width <- 15
        height <- 5 + 1 * nModels_sp
        # We adapt the size of the figure based on the number of models present
        # as it'll need more bars and more CDR3 motifs.
      } else if(plot.oneline==1){
        width <- 20
        height <- 1.5 + 1 * nModels_sp
      } else if(plot.oneline==2){
        width <- 15
        height <- 1.5 + 1 * nModels_sp
      }
      if(!is.null(output.path)){
        filename <- paste0(output.path,"/", modelsCombined_name)
        if (length(comb_res) > 1){
          filename <- paste0(filename, "_", sp)
          # Add species name when there where models corresponding to multiple
          # species in the data.
        }
        filename <- paste0(filename, ".", output.format)

        ggsave(fig, filename=filename, device=output.format,
               width = width/div, height = height, bg="white")
      }
    })

  }

  return.list <- list()
  if(plot){
    return.list$plot <- plot.lst
  }
  return.list$stat <- es.lst
  if(!input1.list){
    return.list$processed.data <- input1.lst
  }
  return(invisible(return.list))

}

